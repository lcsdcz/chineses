# 古诗文练习系统 - 练习模式说明

## 数据结构说明

### 1. 单篇古诗文结构
每篇古诗文现在包含以下字段：
- `id`: 唯一标识符（如 'quanxue', 'xiaoyaoyou'）
- `title`: 标题
- `author`: 作者
- `content`: 完整内容
- `sentences`: 句子数组，每个句子都有唯一ID
- `exercises`: 练习配置数组

### 2. 句子ID结构
每个句子都有唯一ID，格式为：`文章ID_序号`
例如：
- `quanxue_1`: 劝学第1句
- `xiaoyaoyou_3`: 逍遥游第3句

## 练习模式

### 1. 单篇练习模式
- **整篇填后句**: 根据前半句填写后半句
- **整篇填前句**: 根据后半句填写前半句
- **经典名句填空**: 重点句子填空练习
- **随机抽题练习**: 从本文中随机抽取题目

### 2. 多篇组合练习模式
- **经典名句组合**: 从多篇古诗文中随机抽取经典名句
- **唐宋诗词组合**: 从唐宋诗词中随机抽取句子
- **诗经组合**: 从诗经篇目中随机抽取句子
- **自定义组合**: 用户自定义选择多篇文章

## 使用方法

### 1. 单篇练习
```javascript
// 选择单篇文章进行练习
const poem = poemDatabase['古诗文精选'].find(p => p.id === 'quanxue');
const exercise = poem.exercises.find(e => e.type === 'fillBack');
```

### 2. 多篇组合练习
```javascript
// 使用预设组合
const multiExercise = multiPoemExercises['经典名句组合'];

// 自定义组合
const customExercise = {
    title: '我的练习',
    poems: ['quanxue', 'shishuo', 'denggao'],
    randomCount: 8,
    types: ['fillBack', 'fillFront']
};
```

### 3. 随机抽题
```javascript
// 从指定文章中随机抽取句子
function getRandomSentences(poemIds, count) {
    const allSentences = [];
    poemIds.forEach(id => {
        const poem = findPoemById(id);
        allSentences.push(...poem.sentences);
    });
    
    // 随机打乱并选择指定数量
    return shuffleArray(allSentences).slice(0, count);
}
```

## 配置说明

### 1. 练习类型
- `fillBack`: 填后句
- `fillFront`: 填前句
- `auto`: 自动生成
- `random`: 随机抽题
- `mixed`: 混合模式

### 2. 随机抽题配置
- `randomCount`: 抽题数量
- `poems`: 参与抽题的文章ID数组
- `types`: 练习类型数组

## 注意事项

1. **前后句准确性**: 所有句子都经过仔细核对，确保前后句搭配正确
2. **ID唯一性**: 每个句子都有唯一ID，便于管理和随机抽题
3. **练习模式**: 支持单篇、多篇、自定义等多种练习模式
4. **可扩展性**: 可以轻松添加新的古诗文和练习模式

## 示例代码

```javascript
// 获取随机练习题目
function generateRandomExercise(poemIds, count, type) {
    const sentences = [];
    poemIds.forEach(id => {
        const poem = findPoemById(id);
        sentences.push(...poem.sentences);
    });
    
    const selected = shuffleArray(sentences).slice(0, count);
    
    return {
        type: type,
        items: selected.map(s => ({
            id: s.id,
            front: s.front,
            back: s.back
        }))
    };
}
```
